# C源码到可执行文件的流程
**有如下几个步骤**
## 预处理
作为简单的预备工作，比如说将注释替换为空行，把#include展开（这会导致前面出现非常长的代码）,替换宏定义，编译条件并去掉不可能符合的片段。这一步一般不会单独生成文件，但是也可以令保存为.txt文件（.i文件也可以，内容相同，只是简单预处理）。得到类似这个
<a href="https://imgse.com/i/pV7V7jg"><img src="https://s21.ax1x.com/2025/10/05/pV7V7jg.png" alt="pV7V7jg.png" border="0" /></a>

## 编译
这一步将预处理过的代码编译（也可以成为翻译）成编译语言（S文件）。这一步会检查基本的语法，暂时不管逻辑，有语法错误就会报错，编译结束。这一步还会生成中间代码，优化代码（如进行简单的加减乘除运算，优化重复计算的代码）最终把代码转换为汇编指令，汇编语言代码（不同的硬件架构会有不同的结果）。汇编语言已经比较接近机器语言了，不过人学习了过后还是可以看得懂的，比全是0/1还得好很多的。得到类似这个，图中如addl就属于汇编指令
<a href="https://imgse.com/i/pV7VbuQ"><img src="https://s21.ax1x.com/2025/10/05/pV7VbuQ.png" alt="pV7VbuQ.png" border="0" /></a>

## 汇编
这个过程把汇编语言(.s)代码转换为机器可以运行的二进制机器语言（以及符号表（记录定义的函数，变量和它们的地址）和重定位表（以便链接时修改为C标准库中有用的地址））（.o）。由于之前生成了汇编指令，而每个汇编指令和一块格式相对固定的二进制机器语言有着对应关系，汇编只需要逐一地把每一条指令翻译为二进制的机器语言（如汇编语言中add表示加法，如寄存器和寄存器之间的加法在机器语言中操作码就是00000001，如果是直接的数字那么操作码还不一样）。机器语言直接操作内存和CPU，从内存中读取指令，数据，和把数据存入内存，对CPU操作寄存器，用CPU进行运算，和控制流程。机器语言需要特定的软件才能看到（一般给人看的是16进制的）。

## 链接
将机器语言转为可执行文件（.out,.exe等）。链接器打包目标文件和C标准库，链接器通过C标准库中对函数，变量的定义，可以从机器语言中找出各个函数，变量调用，并最终告诉计算机对于每一个地方的机器码应该怎么处理（比如说到了调用printf函数的时候就可以跳转到C标准库中有输出到屏幕作用的地址）（这样可以增强适配性，和系统有关的东西写在C标准库就可以了，不需要在汇编得到的机器语言中体现），有的需要读写，有的只需要执行。例如找不到函数的定义报错就在这一段。同时还可以把数据放一起(又读又写)，代码放一起（CPU只读），方便CPU操作。

## 最终就得到了一个可执行文件