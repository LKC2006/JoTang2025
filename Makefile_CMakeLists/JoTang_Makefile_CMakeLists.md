# Makefile&CMakeLists
***
## 写一份笔记，描述 从 C 源码到可执行文件的完整流程。

**见此文件夹下C_to_exe.md**

***
## 在我们提供的 GitHub 仓库中完成指定的 Task。

**任务1**
对compile_process/demo.c文件尝试进行预处理，编译，汇编，链接步骤，查看每一个步骤对应的输出文件（理解不同步骤的作用），并将每一步的结果保存

demo.c代码是通过循环输出一个数组的各项,在前面各项中间输出空格，并在最后一项后面换行(写的有点独特)
图片中demo.c   

预处理得demo.txt（或者demo.i,但是经过我的观察，文件内容没有区别）（实际上不产生新文件，不过可以通过txt查看）   
这一段上面的#include展开后非常长，但是下面还是没有什么改变
<a href="https://imgse.com/i/pV7V7jg"><img src="https://s21.ax1x.com/2025/10/05/pV7V7jg.png" alt="pV7V7jg.png" border="0" /></a>
编译得demo.s(即汇编语言)（变短了，因为#include展开结果中不需要的内容被舍弃了）
<a href="https://imgse.com/i/pV7VbuQ"><img src="https://s21.ax1x.com/2025/10/05/pV7VbuQ.png" alt="pV7VbuQ.png" border="0" /></a>
汇编得demo.o(即。obj机器语言，二进制)（用字符串的打开方式打开二进制文件获得乱码）
<a href="https://imgse.com/i/pV7VLHs"><img src="https://s21.ax1x.com/2025/10/05/pV7VLHs.png" alt="pV7VLHs.png" border="0" /></a>
链接最终得demo.exe，可执行文件，输出1 2 3 4 5

<a href="https://imgse.com/i/pV7VRHA"><img src="https://s21.ax1x.com/2025/10/05/pV7VRHA.png" alt="pV7VRHA.png" border="0" /></a>
文件附在文件夹中

**任务2**
对MakeFile文件夹中的多文件写一个简单的makefile，要求能通过在终端输入

`make`
得到最终多文件的可执行文件

`make clean`
能删除生成的 .o，.out文件

这个任务解决了我多年以来的一个困惑，知道了原来C也是可以作为项目相互调用，一同运行的。
首先需要理清依赖关系，不能漏掉依赖的头文件还有依赖的情况
```
target : dependencies
	action
```
基本上就是按照这一个格式来，保证路径的正确，逐个先编译为.o,再一起运行为hello.exe就可以了.
Makefile文件夹附在提交文件中.

**进阶**
在makefile的基础上再补充完成cmakelist

CMake的优势在于不用关心内部文件之间的依赖，更加省事，感觉基本上都分类加进去就好了。
我先下载了一个vim，因为需要使用gcc，所以在VScode终端操作，但是由于CMake默认寻找NMake，所以需要这样配置 cmake .. -G "MinGW Makefiles"
由于在源文件目录lib之外还多了一个hello.c，所以我决定分成两步来囊括所有的源文件。第一步是用非常自动的
`aux_source_directory (lib SRC)`
来把lib文件夹里面的源文件全部加入到SRC这个变量中，第二步则是用手动的
`set(SOURCES ${SRC} hello.c)`
来补入hello.c，一起塞进变量SOURCES。还有一些细节问题，比如说最好是让配置过程的文件放到build里面，编译后可执行程序放bin里面（代码实现）（怪不得之前下载个什么东西配置环境变量总是要找到bin目录里面）
CMakeLists文件夹附在提交文件中

***

## 这一步是你理解 C/C++ 这类编译型语言 的基础哦～顺便也可以拿来和 Python 这类解释型语言 做个对比：
编译型语言：需要先经过“编译 → 汇编 → 链接”等步骤，把源代码翻译成机器能直接运行的二进制程序，执行速度快，但调试起来可能稍麻烦。
解释型语言：代码通常不需要提前编译，由解释器一行行读取、执行，开发效率高、调试灵活，但运行速度可能会慢一些。
:bulb: 思考一下：

**为什么 C 程序通常跑得比 Python 快？**

C语言作为编译型语言，在编译等过程过后，最终运行的（可执行程序）都是二进制的机器语言，包快的。（虽然C不是底层语言，肯定会有很多冗杂二进制代码）   
Python作为解释型语言，运行的时候一行一行解释，执行，实际上运行还需要经过大量中间步骤才能成为计算机语言，这些中间步骤导致其运行慢（类似于把编译的过程放到运行中一起了,每一次运行都有源码->字节码->机器语言这个过程，所以一般没有光运行机器语言的C快）（Python其实很多时候也是缓存字节码，一行一行翻译的是字节码，比直接从源码开始好一点，但是肯定比不上C语言之间运行二进制码）

同时，Python中很多函数都经过多层封装，距离底层更远，而C封装更少，翻译为机器的二进制语言步骤更少。

还有一些细节问题，Python逐行解释，不定义变量类型，用一次判断一次，每一个变量占用的内存也更大，而C就没有这些问题。

**为什么很多团队会选择 “C++ 写核心逻辑，Python 负责调度” 的混合模式？**

也就是用Python调用C++函数，这样可以集中二者的优点。C++更接近底层，用来写核心逻辑运行速度更快，用于底层时消耗的内存等资源也更少，底层逻辑一旦写过，基本上不需要修改，意味着不需要天天编译，从而直接运行机器码更高效。，Python有很多高度封装，使用简易的函数，在上层调度可以减少把精力耗费在细枝末节的情况，同时Python对外适配性比较好，和外部对接更加简单。最后，Python解释型语言的特性还可以避免更改调度时编译到不必要的部分，改动时比较轻松。

**解释型语言真的就不用编译吗？（提示：其实 Python 也会先转成字节码 .pyc 再执行哟～）**

所以对于解释型的语言，统一编译到字节码，运行的时候再从字节码一行一行翻译，这样同一编译源码并缓存字节码的过程还是可以提升运行效率的，因此也还是必要的。完全不编译可能太低效了。现在还有能识别热点字节码的技术，缓存天天跑的字节码有利于减少重复操作，也算是编译了。
